/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Rattle.jj */
/*@egen*/options
{
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
               
                 
                           
  OUTPUT_LANGUAGE="c++";
  NAMESPACE="RattleLang";
                               
}

PARSER_BEGIN(Rattle)

PARSER_END(Rattle)

/*
 *
 * Lexer definitions
 *
 */

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  < SINGLE_LINE_COMMENT :
    "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < FORMAL_COMMENT :
    "/**" (~[ "*" ])* "*"
    (
      "*"
    |
      (
        ~[ "*", "/" ] (~[ "*" ])* "*"
      )
    )*
    "/" >
| < MULTI_LINE_COMMENT :
    "/*" (~[ "*" ])* "*"
    (
      "*"
    |
      (
        ~[ "*", "/" ] (~[ "*" ])* "*"
      )
    )*
    "/" >
}

TOKEN [ IGNORE_CASE ] : /* RESERVED WORDS AND LITERALS */
{
  < IF : "IF" >
| < ELSE : "ELSE" >
| < FOR : "FOR" >
| < WHILE : "WHILE" >
| < PRINT : "PRINT" >
| < OR : "OR" >
| < AND : "AND" >
| < NOT : "NOT" >
| < TRUE : "TRUE" >
| < FALSE : "FALSE" >
| < FN : "DEF" >
| < CLASS : "CLASS" >
| < RETURN : "RETURN" >
| < QUIT : "QUIT" >
| < CREATE : "CREATE" >


}

TOKEN : /* LITERALS */
{

  < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >
| 
  < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >
| 
  < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
| 
  < FLOATING_POINT_LITERAL :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)? ([ "f", "F", "d", "D" ])?
  | "." ([ "0"-"9" ])+ (< EXPONENT >)? ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ < EXPONENT > ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ (< EXPONENT >)? [ "f", "F", "d", "D" ]
  |   < DECIMAL_LITERAL > ([ "l", "L" ])?
  | < HEX_LITERAL > ([ "l", "L" ])?
  | < OCTAL_LITERAL > ([ "l", "L" ])?
  >
| 
  < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
| 
  < STRING_LITERAL :
    (
      "\""
      (
        (~[ "\"", "\\", "\n", "\r" ])
      |
        (
          "\\"
          (
            [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
          | [ "0"-"7" ] ([ "0"-"7" ])?
          | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
          )
        )
      )*
      "\""
     )
  >
|
  < CHARACTER_LITERAL :

        "'"
        (
          (~[ "\'", "\\", "\n", "\r" ])
        |
          (
            "\\"
            (
              [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
            | [ "0"-"7" ] ([ "0"-"7" ])?
            | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
            )
          )
        )*
        "'"
    >

}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    | "#"
    )* >
| < #LETTER : 
    [ 
    "$", 
    "A"-"Z", 
    "_", 
    "a"-"z", 
    "\u00c0"-"\u00d6", 
    "\u00d8"-"\u00f6", 
    "\u00f8"-"\u00ff", 
    "\u0100"-"\u1fff", 
    "\u3040"-"\u318f", 
    "\u3300"-"\u337f", 
    "\u3400"-"\u3d2d", 
    "\u4e00"-"\u9fff", 
    "\uf900"-"\ufaff" 
    ] 
  >
| 
  < #DIGIT : 
    [ 
    "0"-"9", 
    "\u0660"-"\u0669", 
    "\u06f0"-"\u06f9", 
    "\u0966"-"\u096f", 
    "\u09e6"-"\u09ef", 
    "\u0a66"-"\u0a6f", 
    "\u0ae6"-"\u0aef", 
    "\u0b66"-"\u0b6f", 
    "\u0be7"-"\u0bef", 
    "\u0c66"-"\u0c6f", 
    "\u0ce6"-"\u0cef", 
    "\u0d66"-"\u0d6f", 
    "\u0e50"-"\u0e59", 
    "\u0ed0"-"\u0ed9", 
    "\u1040"-"\u1049" 
    ] 
  >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
| < PP : "++" >
| < MM : "--" >
}

TOKEN : /* OPERATOR SYMBOLS */
{
  < ASSIGN : "=" >
| < PEQ : "+=" >
| < MEQ : "-=" >
| < UEQ : "@=" >
| < EQ : "==" >
| < OBJDEREF: "OBJ" >
| < GT : ">" >
| < LT : "<" >
| < LE : "<=" >
| < GE : ">=" >
| < NE : "!=" >
| < HOOK : "?" >
| < COLON : ":" >
| < PLUS : "+" >
| < SUBT : "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < REM : "%" >
}

/***********************************************
 *          THE GRAMMAR STARTS HERE            *
 ***********************************************/

ASTCode* code()       :
{/*@bgen(jjtree) Code */
  ASTCode *jjtn000 = new ASTCode(JJTCODE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Code */
  try {
/*@egen*/
  statement()
  (
    statement()
  )*/*@bgen(jjtree) EOF */
  {
    ASTEOF *jjtn001 = new ASTEOF(JJTEOF);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  < EOF >/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/     /*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement()            :
{/*@bgen(jjtree) Statement */
  ASTStatement *jjtn000 = new ASTStatement(JJTSTATEMENT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
  try {
/*@egen*/
  LOOKAHEAD(assignment())
  assignment()
| 	fndef()
| classdef()
| 	block()
| 	ifstatement()	
| 	forloop()
| whileloop()
| 	write()
| LOOKAHEAD(2)
	fn_invoke()
| LOOKAHEAD(method_invoke())
    method_invoke()/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void block()        :
{/*@bgen(jjtree) Block */
  ASTBlock *jjtn000 = new ASTBlock(JJTBLOCK);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/
  "{"
  (
    statement()
  )*
  "}"/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void parmlist()           :
{/*@bgen(jjtree) Parmlist */
  ASTParmlist *jjtn000 = new ASTParmlist(JJTPARMLIST);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Parmlist */
  try {
/*@egen*/
// A parm list should have type declarations too.
  "("
  [
    identifier() " : " identifier()
    (
      "," identifier() " : " identifier()
    )*
  ]
  ")"/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void classdef()           :
{/*@bgen(jjtree) ClassDef */
  ASTClassDef *jjtn000 = new ASTClassDef(JJTCLASSDEF);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassDef */
  try {
/*@egen*/
  < CLASS > identifier()  [ "extends " identifier()  {  jjtn000->polymorphic = true; }]
  "{"
  (
	    classdef()
    |   member_declaration()
    |   fndef()
  )*
  "}"/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void fnbody()         :
{/*@bgen(jjtree) FnBody */
  ASTFnBody *jjtn000 = new ASTFnBody(JJTFNBODY);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FnBody */
  try {
/*@egen*/
  (
    statement()
  )*/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void fnTypeList()             :
{/*@bgen(jjtree) FnTypeList */
  ASTFnTypeList *jjtn000 = new ASTFnTypeList(JJTFNTYPELIST);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FnTypeList */
    try {
/*@egen*/
    " : "identifier()("," identifier())*/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void methoddef()            :
{/*@bgen(jjtree) MethodDef */
  ASTMethodDef *jjtn000 = new ASTMethodDef(JJTMETHODDEF);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDef */
    try {
/*@egen*/
    // a method def is just a function def, but still.
    fndef()/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void fndef()        :
{/*@bgen(jjtree) FnDef */
  ASTFnDef *jjtn000 = new ASTFnDef(JJTFNDEF);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FnDef */
  try {
/*@egen*/
  // A fn definition is the following
  // def nameOfFN : rettype rettype (param : paramType, param : paramType)
  < FN > identifier()[fnTypeList()] parmlist() "{"
       fnbody()
       [
         < RETURN > returnexpr()
         {
           jjtn000->fnHasReturn = true;
         }
       ]
       "}"/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void returnexpr()                   :
{/*@bgen(jjtree) ReturnExpression */
  ASTReturnExpression *jjtn000 = new ASTReturnExpression(JJTRETURNEXPRESSION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnExpression */
  try {
/*@egen*/
  expression() ("," expression())*/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// A member assignment is either varname
void member_declaration()                     :
{/*@bgen(jjtree) #MemDeclaration( 2) */
  ASTMemDeclaration *jjtn000 = new ASTMemDeclaration(JJTMEMDECLARATION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #MemDeclaration( 2) */
  try {
/*@egen*/
  // a : int for instance
  identifier() " : " identifier()
  [
    "="
    expression() | obj_create()
    {
      jjtn000->memHasDefaultVal = true;
    }
  ]/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  2);
    }
  }
/*@egen*/
}

void assignment()             :
{/*@bgen(jjtree) Assignment */
  ASTAssignment *jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
    try {
/*@egen*/
    // A->b->c valid, as is a : int = 4 as is a = 4.
    // If a = 4 we should use type inference.
    (
        LOOKAHEAD(member_identifier())member_identifier() { jjtn000->isObject = true; }
      | LOOKAHEAD(1) identifier() [ " : " identifier() { jjtn000->typeDeclared = true; }]
    )
    (
        ","
        (
           LOOKAHEAD(member_identifier())member_identifier() { jjtn000->isObject = true; }
         | LOOKAHEAD(1)identifier() [ " : " identifier() ]
      )
    )*

    "="

    (
        expression()
        ("," expression())*
    )/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ifstatement()              :
{/*@bgen(jjtree) IfStatement */
  ASTIfStatement *jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/
  < IF > "(" expression() ")" statement()
  [
    LOOKAHEAD(1)
    < ELSE > statement()
    {
      jjtn000->ifHasElse = true;
    }
  ]/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void obj_create()            :
{/*@bgen(jjtree) ObjCreate */
  ASTObjCreate *jjtn000 = new ASTObjCreate(JJTOBJCREATE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjCreate */
  try {
/*@egen*/
  "{"
      < CREATE >  identifier()
       // Possible way to instantiate member variables.
       [
            " where"
             (
                LOOKAHEAD(method_instantiate()) method_instantiate() | member_instantiate()
                [ "," ]
             )*
       ]
  "}"/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void member_instantiate()                 :
{/*@bgen(jjtree) MemInstantiate */
  ASTMemInstantiate *jjtn000 = new ASTMemInstantiate(JJTMEMINSTANTIATE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MemInstantiate */
    try {
/*@egen*/
    identifier() "=" expression()/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void method_instantiate()                    :
{/*@bgen(jjtree) MethodInstantiate */
  ASTMethodInstantiate *jjtn000 = new ASTMethodInstantiate(JJTMETHODINSTANTIATE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodInstantiate */
   try {
/*@egen*/
   identifier()
   // It might be an inner-class.
    (
        "->" identifier() { jjtn000->isObject = true; }
    )*
    arglist()/*@bgen(jjtree)*/
   } catch (...) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
   } {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


void lambda_define()               :
{/*@bgen(jjtree) LabmdaDefine */
  ASTLabmdaDefine *jjtn000 = new ASTLabmdaDefine(JJTLABMDADEFINE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabmdaDefine */
    try {
/*@egen*/
    // Ie : (x, y)->{ return x+y }
    parmlist() fnTypeList()  "->" "{"
    fnbody()
    [
      < RETURN > returnexpr()
      {
        jjtn000->fnHasReturn = true;
      }
    ]
    "}"/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void forloop()          :
{/*@bgen(jjtree) ForLoop */
  ASTForLoop *jjtn000 = new ASTForLoop(JJTFORLOOP);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForLoop */
  try {
/*@egen*/
  < FOR > "(" assignment() ";" expression() ";" assignment() ")" statement()/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void whileloop()            :
{/*@bgen(jjtree) WhileLoop */
  ASTWhileLoop *jjtn000 = new ASTWhileLoop(JJTWHILELOOP);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileLoop */
  try {
/*@egen*/
  < WHILE > "(" expression() ")" statement()/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void write() :
{}
{
  < PRINT >/*@bgen(jjtree) #Write( 1) */
            {
              ASTWrite *jjtn001 = new ASTWrite(JJTWRITE);
              bool jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ expression()/*@bgen(jjtree)*/
            } catch (...) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
            } {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  1);
              }
            }
/*@egen*/          
}

void arglist()          :
{/*@bgen(jjtree) ArgList */
  ASTArgList *jjtn000 = new ASTArgList(JJTARGLIST);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgList */
  try {
/*@egen*/
  "(" [ expression() ]
  (
    "," expression()
  )*
  ")"/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//
// Expressions
//
void expression()            :
{/*@bgen(jjtree) Expression */
  ASTExpression *jjtn000 = new ASTExpression(JJTEXPRESSION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  or_expression()/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void or_expression() :
{}
{
  and_expression()
  (
    < OR >/*@bgen(jjtree) #Or( 2) */
           {
             ASTOr *jjtn001 = new ASTOr(JJTOR);
             bool jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*/ and_expression()/*@bgen(jjtree)*/
           } catch (...) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
           } {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
             }
           }
/*@egen*/       
)*
}

void and_expression() :
{}
{
  compare_expression()
  (
    < AND >/*@bgen(jjtree) #And( 2) */
            {
              ASTAnd *jjtn001 = new ASTAnd(JJTAND);
              bool jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ compare_expression()/*@bgen(jjtree)*/
            } catch (...) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
            } {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/        
)*
}

void compare_expression() :
{}
{
  add_expression()
  [
    "=="/*@bgen(jjtree) #CompEqual( 2) */
         {
           ASTCompEqual *jjtn001 = new ASTCompEqual(JJTCOMPEQUAL);
           bool jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/ add_expression()/*@bgen(jjtree)*/
         } catch (...) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
         } {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/              
| "<>"/*@bgen(jjtree) #CompNequal( 2) */
       {
         ASTCompNequal *jjtn002 = new ASTCompNequal(JJTCOMPNEQUAL);
         bool jjtc002 = true;
         jjtree.openNodeScope(jjtn002);
       }
       try {
/*@egen*/ add_expression()/*@bgen(jjtree)*/
       } catch (...) {
         if (jjtc002) {
           jjtree.clearNodeScope(jjtn002);
           jjtc002 = false;
         } else {
           jjtree.popNode();
         }
       } {
         if (jjtc002) {
           jjtree.closeNodeScope(jjtn002,  2);
         }
       }
/*@egen*/               
| ">="/*@bgen(jjtree) #CompGTE( 2) */
       {
         ASTCompGTE *jjtn003 = new ASTCompGTE(JJTCOMPGTE);
         bool jjtc003 = true;
         jjtree.openNodeScope(jjtn003);
       }
       try {
/*@egen*/ add_expression()/*@bgen(jjtree)*/
       } catch (...) {
         if (jjtc003) {
           jjtree.clearNodeScope(jjtn003);
           jjtc003 = false;
         } else {
           jjtree.popNode();
         }
       } {
         if (jjtc003) {
           jjtree.closeNodeScope(jjtn003,  2);
         }
       }
/*@egen*/            
| "<="/*@bgen(jjtree) #CompLTE( 2) */
       {
         ASTCompLTE *jjtn004 = new ASTCompLTE(JJTCOMPLTE);
         bool jjtc004 = true;
         jjtree.openNodeScope(jjtn004);
       }
       try {
/*@egen*/ add_expression()/*@bgen(jjtree)*/
       } catch (...) {
         if (jjtc004) {
           jjtree.clearNodeScope(jjtn004);
           jjtc004 = false;
         } else {
           jjtree.popNode();
         }
       } {
         if (jjtc004) {
           jjtree.closeNodeScope(jjtn004,  2);
         }
       }
/*@egen*/            
| ">"/*@bgen(jjtree) #CompGT( 2) */
      {
        ASTCompGT *jjtn005 = new ASTCompGT(JJTCOMPGT);
        bool jjtc005 = true;
        jjtree.openNodeScope(jjtn005);
      }
      try {
/*@egen*/ add_expression()/*@bgen(jjtree)*/
      } catch (...) {
        if (jjtc005) {
          jjtree.clearNodeScope(jjtn005);
          jjtc005 = false;
        } else {
          jjtree.popNode();
        }
      } {
        if (jjtc005) {
          jjtree.closeNodeScope(jjtn005,  2);
        }
      }
/*@egen*/           
| "<"/*@bgen(jjtree) #CompLT( 2) */
      {
        ASTCompLT *jjtn006 = new ASTCompLT(JJTCOMPLT);
        bool jjtc006 = true;
        jjtree.openNodeScope(jjtn006);
      }
      try {
/*@egen*/ add_expression()/*@bgen(jjtree)*/
      } catch (...) {
        if (jjtc006) {
          jjtree.clearNodeScope(jjtn006);
          jjtc006 = false;
        } else {
          jjtree.popNode();
        }
      } {
        if (jjtc006) {
          jjtree.closeNodeScope(jjtn006,  2);
        }
      }
/*@egen*/           
]
}

void add_expression() :
{}
{
  mul_expression()
  (
    "+"/*@bgen(jjtree) #Add( 2) */
        {
          ASTAdd *jjtn001 = new ASTAdd(JJTADD);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ mul_expression()/*@bgen(jjtree)*/
        } catch (...) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
        } {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/        
    | "-"/*@bgen(jjtree) #Subtract( 2) */
          {
            ASTSubtract *jjtn002 = new ASTSubtract(JJTSUBTRACT);
            bool jjtc002 = true;
            jjtree.openNodeScope(jjtn002);
          }
          try {
/*@egen*/ mul_expression()/*@bgen(jjtree)*/
          } catch (...) {
            if (jjtc002) {
              jjtree.clearNodeScope(jjtn002);
              jjtc002 = false;
            } else {
              jjtree.popNode();
            }
          } {
            if (jjtc002) {
              jjtree.closeNodeScope(jjtn002,  2);
            }
          }
/*@egen*/             
)*
}

void mul_expression() :
{}
{
  unary_expression()
  (
    "*"/*@bgen(jjtree) #Times( 2) */
        {
          ASTTimes *jjtn001 = new ASTTimes(JJTTIMES);
          bool jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ unary_expression()/*@bgen(jjtree)*/
        } catch (...) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
        } {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/          
| "/"/*@bgen(jjtree) #Divide( 2) */
      {
        ASTDivide *jjtn002 = new ASTDivide(JJTDIVIDE);
        bool jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
      }
      try {
/*@egen*/ unary_expression()/*@bgen(jjtree)*/
      } catch (...) {
        if (jjtc002) {
          jjtree.clearNodeScope(jjtn002);
          jjtc002 = false;
        } else {
          jjtree.popNode();
        }
      } {
        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002,  2);
        }
      }
/*@egen*/           
)*
}

void unary_expression() :
{}
{
  < NOT >/*@bgen(jjtree) #UnaryNot( 1) */
          {
            ASTUnaryNot *jjtn001 = new ASTUnaryNot(JJTUNARYNOT);
            bool jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ unary_expression()/*@bgen(jjtree)*/
          } catch (...) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
          } {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  1);
            }
          }
/*@egen*/             
| "+"/*@bgen(jjtree) #UnaryPlus( 1) */
      {
        ASTUnaryPlus *jjtn002 = new ASTUnaryPlus(JJTUNARYPLUS);
        bool jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
      }
      try {
/*@egen*/ unary_expression()/*@bgen(jjtree)*/
      } catch (...) {
        if (jjtc002) {
          jjtree.clearNodeScope(jjtn002);
          jjtc002 = false;
        } else {
          jjtree.popNode();
        }
      } {
        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002,  1);
        }
      }
/*@egen*/              
| "-"/*@bgen(jjtree) #UnaryMinus( 1) */
      {
        ASTUnaryMinus *jjtn003 = new ASTUnaryMinus(JJTUNARYMINUS);
        bool jjtc003 = true;
        jjtree.openNodeScope(jjtn003);
      }
      try {
/*@egen*/ unary_expression()/*@bgen(jjtree)*/
      } catch (...) {
        if (jjtc003) {
          jjtree.clearNodeScope(jjtn003);
          jjtc003 = false;
        } else {
          jjtree.popNode();
        }
      } {
        if (jjtc003) {
          jjtree.closeNodeScope(jjtn003,  1);
        }
      }
/*@egen*/               
| LOOKAHEAD(indexed_expression()) indexed_expression()
| primary_expression()
}

void indexed_expression()                     :
{/*@bgen(jjtree) IndexedExpression */
  ASTIndexedExpression *jjtn000 = new ASTIndexedExpression(JJTINDEXEDEXPRESSION);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IndexedExpression */
    try {
/*@egen*/
    primary_expression() "[" number() "]"/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void primary_expression() :
{}
{
    (
          literal()
        | LOOKAHEAD(lambda_define())
          lambda_define()
        | LOOKAHEAD(tuple_define())
            tuple_define()
        | LOOKAHEAD(fn_invoke())
          fn_invoke()
        | LOOKAHEAD(method_invoke())
            method_invoke()
        | LOOKAHEAD(3)
                dereference()
        | obj_create()
        | "(" expression() ")"
    )
}

// A tuple is defined as one or more
// expressions that form values.
void tuple_define()              :
{/*@bgen(jjtree) TupleDefine */
  ASTTupleDefine *jjtn000 = new ASTTupleDefine(JJTTUPLEDEFINE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TupleDefine */
    try {
/*@egen*/
    "[" expression() (","expression())* "]"/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void fn_invoke()           :
{/*@bgen(jjtree) FnInvoke */
  ASTFnInvoke *jjtn000 = new ASTFnInvoke(JJTFNINVOKE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FnInvoke */
  try {
/*@egen*/
  identifier() arglist()/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void method_invoke()               :
{/*@bgen(jjtree) MethodInvoke */
  ASTMethodInvoke *jjtn000 = new ASTMethodInvoke(JJTMETHODINVOKE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodInvoke */
   try {
/*@egen*/

   identifier()
    (
        "->" identifier() { jjtn000->isObject = true; }
    )+
    arglist()/*@bgen(jjtree)*/
   } catch (...) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
   } {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void literal() :
{}
{
  number()
| character()
| string()
| Bool()
}

void identifier()             :
{
  Token* t;/*@bgen(jjtree) Identifier */
  ASTIdentifier *jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000->tokenValue = t->image;
  }/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void member_identifier()                :
{
    Token* t;/*@bgen(jjtree) MemIdentifier */
  ASTMemIdentifier *jjtn000 = new ASTMemIdentifier(JJTMEMIDENTIFIER);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) MemIdentifier */
    try {
/*@egen*/
    // One and then many identifiers.
    t = < IDENTIFIER >
    {
        jjtn000->tokenValue = t->image;
        jjtn000->isObject = true;
    }
    (
    "->" identifier()
    )+/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}


void dereference()              :
{
  Token* t;/*@bgen(jjtree) Dereference */
  ASTDereference *jjtn000 = new ASTDereference(JJTDEREFERENCE);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Dereference */
   try {
/*@egen*/
   LOOKAHEAD(member_identifier())member_identifier()/*@bgen(jjtree)*/
                                                     {
                                                       jjtree.closeNodeScope(jjtn000, true);
                                                       jjtc000 = false;
                                                     }
/*@egen*/ { jjtn000->isObject = true; } | LOOKAHEAD(1)identifier()/*@bgen(jjtree)*/
   } catch (...) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
   } {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


void character()            :
{
  Token* t;/*@bgen(jjtree) Character */
  ASTCharacter *jjtn000 = new ASTCharacter(JJTCHARACTER);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Character */
  try {
/*@egen*/
  t = < CHARACTER_LITERAL >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000->tokenValue = t->image;
  }/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void string()         :
{
    Token* t;/*@bgen(jjtree) String */
  ASTString *jjtn000 = new ASTString(JJTSTRING);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) String */
    try {
/*@egen*/
    t = < STRING_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000->tokenValue = t->image;
    }/*@bgen(jjtree)*/
    } catch (...) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
    } {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void number()         :
{
  Token* t;/*@bgen(jjtree) Number */
  ASTNumber *jjtn000 = new ASTNumber(JJTNUMBER);
  bool jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Number */
  try {
/*@egen*/
  t = < FLOATING_POINT_LITERAL >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000->tokenValue = t->image;
  }/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void Bool() :
{}
{/*@bgen(jjtree) True */
  {
    ASTTrue *jjtn001 = new ASTTrue(JJTTRUE);
    bool jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  < TRUE >/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/      
|/*@bgen(jjtree) False */
  {
    ASTFalse *jjtn002 = new ASTFalse(JJTFALSE);
    bool jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/ < FALSE >/*@bgen(jjtree)*/
  } catch (...) {
    if (jjtc002) {
      jjtree.clearNodeScope(jjtn002);
      jjtc002 = false;
    } else {
      jjtree.popNode();
    }
  } {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/       
}